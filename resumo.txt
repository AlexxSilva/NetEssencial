
Tipos de dados (Valor x Referência) - C# Linguagem fortemente tipada

Valor:

Variaveis do tipo valor não podem conter o valor null 
Os dados são armazenados na stack (Numericos: int, float, decimal)
								  ( Não numericos: bool, char, enum, datetime (struct))

Referência: 

Os dados fica armazenado na heap e cada variavel contem uma referencia ao local
onde os dados estão armazenados - Ponteiro para onde o dado está armazenado (string, object, class, dynamic).


Definindo variaveis ou constantes : Definir tipo, nome e atribuição de valores. (const - constantes)

Constantes: não podem ser alterados
variaveis : podem ser alteradas
(o tipo define o tamanho que a variavel usa de memoria.)

tipos valores:
//byte - 1 byte
short -  2 bytes
int -    4 bytes
float -  4 bytes
lont -   8 bytes
double - 8 bytes
decimal - 16 bytes (usado para valores financeiros)

Tipos strings são imutaveis, ou seja não podem ser alteradas. 
Quando concatenar ou passar valor ele cria um novo espaço de memoria.
(usar stringBuilder)

Tipo object é genérico, ele aceita qualquer tipo de dado pois todos os tipos herdam de object.
dynamic (semelhante ao object, mas é util para usar recursos como reflaction ou linguagem dinamica). 
(Todos os objetos herdeam de object)

Nullable types

Tornar um tipo de valor um tipo que aceita valor null.
int valor = null; (erro não é permitido) - tipo não anulavel
Nullable<int> valor = null; (aceita) - é um nullable type
int? valor = null;

nomenclaturas

PascalCase - primeira letra maiscula, e a letra de cada palavra seguinte maiscula.
usado em classes, métodos, interfaces e propriedades (entityframework, usa essa estrutura
pra criar os campos de tabelas).

CamelCase - primeira letra minuscula, e a letra de cada palavra seguinte maiscula.
(usado em variaveis, parametros e campos internos privados).

snake_case - primeira letra minuscula,  a letra de cada palavra seguinte minuscula,
com _ antes. (banco de dados).

(formas de juntar textos - concatenação, interpolação ($), placeholders usando chaves para dizer a ordem
que vou colocar os valores e depois virgula as variaveis.)

Sequencia de Escapes (\b - backspace, \n - nova linha, \\ barra invertida \? interrogação).

A linguagem c# é estaticamente tipada em tempo de compilação, ou seja depois que uma variavel é 
declarada, seu tipo não pode mais ser alterado ou usado para armazenar outro tipo de dado,
mas pode ser convertido para outro tipo desde que seja convertivel para outro tipo de dado. 

conversão implicita - o compilador faz automaticamente se ele entender q é conversivel
conversão explicita - feita de forma manual

conversão de strings (ToString())
Como todos os objetos herdam de object, todos os objetos herdam o método ToString

conversões também podem ser feitas com o uso da classe convert.

conversão de ampliação ou estreitamento entre dois tipos de dados tem exito se não houver perda de dados,
caso perca de dados o erro é OverflowException

Operadores aritméticos
+ - / * (% resto da divisão) 

Uso da classe Math para calculos matematicos.

inferencia de tipos (Tipo padrão é o tipo explicito)
Declaração do tipo implicito com var (deve ser definido o valor para que o compilador possa inferir o tipo de dados)
Não é possivel atribuir null.
multiplas variaveis do tipo implicito não podem ser inicializadas na mesma instrução.
não podemos alterar o tipo da variavel depois de inicializada.

quando usar var
tipos anonimos, laços for e foreach, instruções using

operadores de atribuição
=
+=
-=
*=
/=
%=

operador + e += com strings (concaterna) - null representa uma string vazia

constantes 
valores imutaveis que são conhecidos em tempo de execucao e não mudam durante a vida util do programa.


Incremento e decremento ++ e --

pos incremento  x++ (primeiro resolve a expressão depois incrementa - o valor da expressão fica sem o valor do incremento)
pre incremento ++x (incrementa e depois resolve a expressão)


operadores relacionais

==
>
<
>=
<=
!=

operadores logicos
&& - and
|| - or
! - not (negação)

ordem de precedência e associatividade
* , /, %, + , - [], ()

!, &&, ||

++, --, *, -

nullable referente types
Tipos de referencia que não tem referencia nenhuma (null)

lembrando que tipos valor são armazenados na stack, e tipos referencia é armazenado
na stack uma referencia para onde os dados estão armazenados e armazena na heap.

Quando o tipo referencia e nulo,eu não tenho essa referencia para o dado na heap,
pois não tem nada armazenado la.

string nome = null; (converting null literal or possible null value to non-nullable type)
nome.toUpper() - System.NullReferenceException 'Object reference not set to an instance of an object'

Nullable reference types  - nos alerta sobre a possibilidade de ocorrer um erro
envolvendo manipulação nula. Tem a finalidade de minimizar a chance de aplicativo lancar
um System.NullReferenceException

definir no arquivo de projeto : <Nullable>enable</Nullable>

(null condicional operation .? ou Nullable<T>)

string? nome = null;
nome?.ToUpper();


=============================================

Estruturas de controle
IF / IF ELSE / IF ELSE IF / SWITCH / ESTRUTURA DE REPETIÇÃO / WHILE / FOR / DO WHILE / BREAK E CONTINUE

=============================================

Classes e métodos

Classe : Tipo de referência, estruturado que contém os membros:  (atributos - propridades e campos ) (metodos - comportamentos)

Uma classe é uma abastração de um objeto do mundo real.

ex: Pessoa - atributos - nome, idade, sexo - metodos - Comer, andar, caminhar

Atravês da instancia da classe podemos criar objetos do tipo pessoa. (new)

obs sobre uso de memoria

Quando criando um objeto, a variavel é armazenada na stack, e o objeto é armazenado
na heap, onde a stack guarda a referencia para onde o dado está armazenado na heap.

caso eu crie outro objeto e ele recebe o primeiro objeto, os dois apontam para a mesma referencia 
na heap, ou seja se alterar as informações de 1 o outro também altera.

Objeto - Instancia de uma classe, criada pelo operador (new)

Objetos possuem caracteristicas proprias de algo do mundo real,
enquanto a classe descreve todos os objetos de um tipo particular.

métodos

Representa o comportamento das classes, e executam ações e realiza a comunicação entre objetos
contem	 um bloco de codigo com instruções que serão executadas quando forem chamadas.

Metodo main é o ponto de entrada para todas as aplicações  e é chamado pelo CLR (Common language runtime)
quando o programa é iniciado.

Funções são declaradas fora de uma classe, no caso em c# não existe pois os blocos de codigo
sempre são declarados dentro de classes, e nesse caso são metodos.

tipo de retorno + Nome (pascal case) + Lista de parametros +  Corpo do método

Ao tentar chamar os métodos da classe, vc perceberá mais métodos que você não criou, porque todas
as classes herdam de object, e na classe object que elas foram criadas.

Quando o método tem apenas uma instrução, eu posso usar um formato de expressão compacto

ex: 

 public void ExibirDataAtual()
{
   MessageBox.Show(DateTime.Now.ToShortDateString());
}

alterar para 
   public void ExibirDataAtual() =>
            MessageBox.Show(DateTime.Now.ToShortDateString());

passagem de parametros

 public void Saudacao(string nome , string data) 

contrutores

São tipos especiais de metodos usados para criar e inicializar objetos de uma classe. Sempre
que uma classe é instanciada, o contrutor é chamado.

Ao criar  uma classe, um construtor padrão sem parametros é criado automaticamente,
e ele é usado para criar uma instancia da classe e definir valores padrão para os membros da classe.
Ao instanciar a classe o contrutor padrão atribui os valores padrão aos membros da classe.


contrutores tem o mesmo nome da classe e não possuem retorno (podem possuir parametros para 
inicializar os membros da classe.)

eu posso ter mais de um contrutor e também posso chamar um contrutor em outro para passar os valores 
já preenchidos.

ex:
// esse contrutor chama o contrutor com dois parametros
public Aluno(string nome, int idade, string sexo, string aprovado) : this(nome, idade)
        {
            Sexo = sexo;
            Aprovado = aprovado;
        }

        public Aluno(string nome, int idade)
        {
            Nome = nome;
            Idade = idade;

        }

Palavra chave This -Referece a instancia atual da classe.
passar parametro da instancia atual para outros métodos.
invocar outro contrutor da mesma classe.
também é usada  como um modificador do primeiro parametro de um modo de extensãõ ???

Métodos com retorno (return)

Assinatura do método leva o nome do parametro, numero de parametros, tipo de parametro, ordem dos parametros

não é possivel ter dois métodos iguais, mas com o mesmo nome sim desde que uma das opcoes acima seja
diferente.

Passando argumento por valor e por referencia

Valor: Uma copia do valor do argumento é feita e passada para o parametro do método chamado
Referencia: Passa a referencia ao mesmo local da memória dos argumentos, nenhuma copia
é passada, dado ao método a capacidade de acessar e modificar a variavel original do chamador.

Usa as palavras ref ou out.

diferença out x ref
out transfere os dados para fora do método e nao para dentro dele
variaveis no argumento out não precisam ser inicializadas antes de serem passadas em
uma chamada de metodo, no entanto o método chamado deve atribuir um valor ao parametro
definido com a palavra-chave out antes que  método seja retornado.

parametro: o valor que  método espera receber quando for chamado
argumento: representa o valor que você passa para o parametro

argumentos nomeados, eu passo o argumento pelo nome dos parametros e não pela ordem que foram
colocados.

parametros opcionais
permite definir parametros que o chamador pode omitir. (precisa ter um valor padrão na sua definição,
pois se nenhum argumento for enviado para esse parametro, o valor poderá ser usado.)

metodos estaticos (static)
(classes, interfaces, structs, campos, métodos, propridades, operadores, eventos, contrutores).

Esses métodos não dependem da criação e instancia do objeto para serem acessados. 
Classe.metodostatico(parametros)
métodos estaticos não possuem ligação com um objeto, eles não podem usar variaveis de instancia,
que são variaveis de objeto.

campos staticos (campos e propriedades) - pertencem a classe e podem ser acessados sem o new

armazenamento Stack x heap

Quando um objeto é instanciado, a referencia do objeto é guardada na stack, e as informações guardadas
na heap. No caso de campos estaticos, eles são guardados direto na heap, e cada objeto armazenado na
heap compartilha a mesma referencia ao campo estatico.

Contrutor statico - inicializar qualquer membros estaticos  ou para executar uma ação especifica que
precisa ser executada apenas uma vez.

ele é chamado automaticamente antes que a primeira instancia seja criada ou que quaisquer membros
estaticos seja referenciados.

Um contrutor estatico nao usa modificadores de acesso, nem tem parametros
Uma classe ou struct só pode ter um unico contrutor statico.
um contrutor statico não pode ser chamado diretamente
O usuario não tem controle sob quando o contrutor statico é executado no programa
inicializa com o valor padrão quando não inicializado
se gerar uma exceção, o runtime nao invocara uma segunda vez e o membro estatico permacerá
não inicializado durante o tempo de vida od projeto.

Propriedades // a abordagem se acessar as variaveis publicas seja pela instancia da classe ou 
pela propria classe diretamente sem restricao viola um dos paradigmas da orientação a objetos
que é o encapsulamento.

As propriedades foram criadas para resolver esse problema.

Uma propridade é um membro de classe que fornece um mecanismo para ler, gravar e calcular o valor
 de um campo privado.
Podem ser usadas como membros publicos, mas possuem metodos especiais chamados de acessadores (get set)
os acessadores permite que os dados sejam acessados com facilidade e ainda ajuda a promover a segurança
e a flexibilidade dos métodos.
A propridade permite que uma classe exponha uma maneira publica de obter e definir valores, enquanto
oculta o codigo de implamentacao ou verificaçao.

get - retorna o valor do campo privado
set - permite realizar alguma validacao de dados antes de atribuir um valor ao campo privado.
//propriedades leitura e gravação,  somente leitura, somente gravação.

leitura e gravacao 
public string? Nome { get; set; }

somente leitura
public string? Nome {get;}

somente gravação

private nome;
public string? Nome
{
    set { nome = value; }
}


Structs
É um estrutura semelhante a classe, composta por tipos de dados e funcionalidades (metodos,
constantes, contrutores, propriedades, indexadores, operadores e outros tipos de estruturas)

Structs são do tipo valor, e não referencia (são armazenados na stack)

struct name
{
}

diferença de struct e classe em relação a memoria

structs c1 e c2
c1.valor = 1;
c2 = c1; (nesse momento os dados das duas structs estão armazenados na stack, e duplicado o valor)

stack
c1 ==== valor =1
c2 ==== valor =1

classes c1 e c2
c1.valor = 1;
c2 = c1; (nesse momento a referencia da memoria na stack das duas classes apontam para o mesmo espaço alocado na heap)

stack                            heap
c1 ==== ref = c1---------------- mesmo espaço
c2 ==== ref = c2---------------- de memoria (valor = 1)

quando usar struct 
Instancias do tipo pequena e de curta duração ou se forem comumente incorporadas em outros objetos.

evite definir uma struct a menos que:
Represente logicamente um unico valor, semelhante a tipos primitivos.
Tenha uma tamanho de instancia inferior a 16 bytes.
é imutavel
Não precisa sofrer conversão para tipos referencia (boxing) - com frequencia

Enum ou enumeration (tipo valor, memória stack)

tipo de de dado especial definido pelo usuario, é um conjunto de constantes nomeadas do tipo numerico
que torna o programa mais facil de entender.

pode ser feita diretamente dentro de um namespace,  classe ou struct.

por padrão os membros de uma enum são do tipo int; o primeiro tendo o valor 0, e restante icrementado de 1.

o enum pode ser acesso por nome

modificadores de acesso

palavras para especificar o acesso a um membro (campo, propriedade,metodo) ou tipo (class, struct, etc)

public - pode ser acessado por qualquer outro codigo no mesmo assembly, ou outro assembly.

private -   so pode ser acessado por outro codigo na mesma classe ou struct

internal - pode ser acessado por qualquer codigo no mesmo assembly.

protected - pode ser acessado por qualquer codigo no mesmo assembly ou se a classe for herdada
em outro assembly

file (C#10) - Restringe o escopo e visibilidade de um tipo em nivel superior ao arquivo no que ele foi declarado.

estratégia - limitar a visibilidade de seus tipos e ou membros, restringindo-os a apenas a quem
precisa realmente acessar o tipo ou membro.

tratamento de erros (try catch)
trata exceções, erros encontrados em tempo de execução do programa
se o sistema não tratar a excessão o sistema para a execução do programa com a mensagem do erro.
finally - outro bloco que será executado ao dar a exceção para liberar os recursos usados ao realizar outra tarefa.

propridades da exceção

Message - mensagem explicando o erro da exceção
StackTrace - descreve onde ela ocorreu
InnerException - se a exceção for lançada por outra exceção, contem a referencia da antiga exceção.

Tipos anonimos T (3.0 C#)

Fornecem uma maneira conveniente para encapsular um conjunto de propriedades, somente leitura
em um unico objeto sem precisar definir explicitamente o tipo.

O nome do tipo é definido pelo compilador e não está disponivel no codigo fonte e o tipo de cada
propriedade é inferido pelo compilador.

inicializado com new combinado com inicializador de objetos.
a palavra chave var recupera a referencia do objeto 

são derivados de object

var aluno = new 
{
    Nome = "Maria",
    Idade = 42
};

tipos anonimos são somente leitura.
tipos anonimos permitem propriedades anonimas


var aluno = new 
{
    Nome = "Maria",
    Idade = 42,
    Endereco = new {Id= 1, Cidade = "SP"}
};

//utilidade
normalmente são usados em uma clausula select de uma expressão de consulta geralmente
com linq, para retornar um conjunto de propriedades de cada objeto na sequencia da origem.

Partial class
Permite que uma classe venha a ser implementada em multiplos arquivos fisicos com extensão cs.
(classes parciais podem usar mais de um arquivo cs e ser a mesma classe)
podemos criar classes, interfaces, structs e metodos parciais com o modificador partial

Eu posso ter duas classes parciais com o mesmo nome, separadas em arquivos cs diferentes,
o compilador irá entender que é a mesma classe.

regras
classes parciais devem estar no mesmo assembly
mesmo nivel de acessibilidade
atribuitos são para todas as partes da classe

quando usar
grandes projetos, permite que varios programadores trabalhem ao mesmo tempo
codigos gerados automaticaamente, o codigo pode ser adicionado a classe sem precisar recriar o arquivo
de origem
ao usar geradores de codigo fonte  para adicionar uma funcionalidade adicional a classe


//arrays e coleções
arrays - numeros fixo de opcoes do mesmo objeto
coleções - uma maneira flexivel de trabalhar com grupos de objetos

Coleções não genéricas:System.Collections

ArrayList, SortedList, Queue, HashTable

Genéricas: System.Collecions.Generic (indicadas, melhor desempenho)

List, SortedList, Queue, LinkedList, HashSet, SortedSet, Dictinary, SortedDictionary

==================

Arrays (usado para armazenar mais de um valor literal do mesmo tipo em uma variavel do mesmo nome)

Conjunto do mesmo tipo de dados e de tamanho fixo.
Uma dimensão: Vetor

__ __ __ __ __ __

mais de uma dimensão: Matriz (abaixo de duas dimensões - linhas e colunas)

__ __ __ __ __ __
__ __ __ __ __ __
__ __ __ __ __ __
__ __ __ __ __ __

declaração 

int [] lista = new int[3]{1,2,3};

sintaxe simplificada

 string[] nomes2 = { "Alex", "Jeniffer" };

 cada elemento é um indice, que começa do 0. No caso acima o indice 1 contem o valor "Jeniffer"

 arrays são armazenadas sua referencia na stack, e os dados na heap (também são objetos)

 //percorrer arrays (for, while, do while) usando o contador como indice no array
 A classe array está no namespace system e fornece algumas propriedades para trabalhar,
 como length, rank, copy, Clear, Sort, etc).
com o foreach é possivel percorrer sem usar o indice e definir o tamanho do array.

Classe Array (metodos para trabalhar com arrays)

Array.Reverse(nome_array) inverter a sequencia
Array.Sort(nome_array) Ordenar
Array.BinarySearch(nome_array, objeto) - busca em um array um valor, atraves do algoritmo
de busca binaria. retorna o indice do valor, ou negativo se não encontrado.

Array como parametros de métodos (params)

aceita como argumento valores separados por virgula,e converte em array.
Ex:

void calcSoma(params int[]numeros)
{
}

posso passar como valor:

calcSoma(1,2,3,4,5,6)

params não pode ter outro parametro no método antes dele. Só ele ou ele por ultimo.

Arrays dimensionais

suporta até 32 dimensoes

arrays bidimensionais são como se fosse tabelas (linhas e colunas)
int[,] numeross2 = new int[3,3];
int[,]a = { {0,1}, { 2,3 } };

Array bi dimensional - laço for
usar o laço for para ler e recuperar os elementos do array bidimensional
getLength(0)

//for com array
            int[,] n = new int[2, 3] { { 1, 4, 2 }, { 3, 6, 8 } };

            for (int i = 0; i < n.GetLength(0); i++) // primeira dimensão linhas
            {
                for (int j = 0; i < n.GetLength(1); i++) // segunda dimensão colunas
                {
                    
                }
            }

// com foreach - percorre os elementos de forma crescente de indice começando do zero até lenght -1.
 foreach (int i in nz)
            {
                
            }

//arraylist
coleção não generica que armazena elementos de varios tipos
Essa coleção é uma alternativa a array e também pode ser indexada individualmente e permite
alocação dinamica de memoria, inclusao, pesquisa e classificacao de elementos de coleção.

namespace System.Collection

ArrayList() - usado para criar uma instancia de classe ArrayList, que está vazia e sem capacidade
inicial. (capacity e count)

ArrayList(int32) - usado para criar uma instancia de classe ArrayList, que está vazia e TEM capacidade
inicial especificada

ArrayList(ICollection) - usado para criar uma lista de Array, com elementos de uma coleção especifica
e tendo a mesma capacidade inicial que é copiado da seleção.

criar NEW, e adicionar com Add

capacity e count (aumentam conforme eu adiciono elementos na lista se for criado um array list sem parametros)
permite qualquer tipo de dados

inicializadores de objetos (object inicializer) -inicializar em uma unica etapa

Add - permite adicionar um elemento no final do arraylist
insert(int index, Object value)
lista.Add("Alex");//adiciona no final
lista.Insert(2, "Jeniffer"); //adiciona na posicao 2 e realoca os outros elementos

//posso incluir uma coleção no final ou em uma posição do arraylist, realocando os outros elementos
list.AddRange(array1); //adicionar lista
list.InsertRange( 2, array1 ); //adicionar lista realocando


remover
Remove (Object value)
removeAt (index)
RemoveRange (int index, int count)
lista.Remove(null);//vai remover a primeira ocorrencia que tiver como null
lista.Remove("Maria");
lista.RemoveAt(1); //remove o da posição index 1
lista.RemoveRange(0, 2); // remove começando da zero e duas posicoes

//verificar se existe na arraylist
.Contains() retorna true ou false.

//ordenar
.Sort (usa o Quicksort)

//remover toda a lista (limpar)
.Clear()

Por ser um tipo Object, o desempenho dele não é bom, pois todos os itens ficam como object,
e tem que ser convertido pro tipo correto. (boxing e Unboxing) - conversão tipo de valor para objeto,
e objeto para valor.

Boxing - Conversão do tipo Value Type , para Reference Type
Unboxing - conversão do tipo Reference Type para Value Type 
(essas operacoes diminuem o desempenho da lista)
Parse - converter uma string para um tipo especifico.
Cast - converter um tipo objeto para um tipo espefifico (que já é compativel)

A recomendação é usar é usar a coleção List<T>

Coleção LIST

A coleção List<T> é uma coleção de objetos fortemente tipados que podem ser acessados usando 
indice que inicia em zero, e possui métodos para classificar, pesquisar, modificar, e manipular listas.
É uma versão genérica da ArrayList, sendo equivalente, em caracteristicas, com mais performance.

a classe list<T> podem ser usadas para criar coleções de tipos diferentes, onde T representa o tipo
do objeto que pode ser inteiro, string, double,etc. e também pode ser um tipo complexo com a classe
definida pelo usuário.

pode conter elementos do tipo especificado T, faz a verificação do tipo em tempo de compilação
e não faz boxing e unboxing pois é genérica.

podem ser adicionados usando elementos: add(), addRange(), Insert(), InsertRange(), ou usando
a sintexe de inicializador de coleção.

Uma List<T> é dinamica e pode ser redimencionada.

Uma List<T> inicia vazia e seus elementos são alocados sob demanda.

São tipo referencia: uma variavel refere-se a um objeto real, que deve ser armazenao na memoria heap

para criar um list<T> temos que especificar o tipo e usar a palavra NEW
podemos usar add para incluir elementos ou usar inicializadores de coleção para criar uma list<T>
em uma unica etapa.

tem os mesmos metodos da classe arralist (Add, insert, AddRange, InsertRange, sort, clear, remove)
da pra percorrer com for e foreach, acesso aos elementos pelo indice.
uso do contains para saber se está na lista.

List<T>
System.Collections.Generic
Coleção de objetos fortemente tipados
Não realiza operação boxing e unboxing
Apresenta melhor desempenho
Apresenta segurança de tipo
Recomendado para tratar objetos homogeneos e heterogenios

ArrayList
System.Collection
Coleção que pode armazenar itens de diversos tipos de dados. Não é fortemente tipada
Realiza operação boxing e unboxing
Apresenta um desempenho menor
Não apresenta segurança de tipo
Seu uso deve ser evitado.

//metodos Find da List<T>
Find (primeiro elemento que corresponde a um predicado fornecido),
FindLast (ultimo elemento), FindIndex, FindLastIndex, FindAll (Coleção de elementos que corresponde a um predicado)

Um predicado é uma função/metodo de argumento unico (condicao) - critério que retorna um valor booleano.

os métodos Find esperam um predicado (metodo ou função que retorna um bool) ex:

List<string> frutas = new() { "Uva", "Banana", "Pera", "Maça", "Abacate", "Laranja", "Morango" };

var fruta = frutas.Find(Procura);

 static bool Procura(string item) // o parametro do metodo procura é cada elemento do list, pra saber algum inicia com L
{
   return item.StartsWith("L");
}

ao inves de passar um método eu também posso passar uma expressão lambda (paradigma funcional)

Expressão lambida - é uma função anonima, ela não tem nome
os parametros de entrada tem que estar do lado esquerdo do operador  =>
e definir a expressão ou bloco de instruções do lado direito.

x => x * x;

List<T> x IEnumerable

- IEnumerable é uma interface (descreve um comportamento) - List implementa a interface IEnumerable.
- IEnumerable é somente leitura
- List Implementa uma variedade de métodos capazes de acessar e alterar a coleção.
- IEnumerable possui um método para retornar o próximo item da coleção
  Não precisa ter toda a lista em memória
  Não sabe quantos elementos a coleção possui
  Ao ser iterada em um laço foreach ele vi retornando o proximo item até o fim da coleção

- List possui toda a coleção em memoria e sabe quantos itens possuem a coleção. (A coleção já é numerada)

-IEnumerable da ao compilador a chance de adiar a execução (deferred execution), somente é executada ao ser
iterada em laço foreach/for, ou ter o valor extraido (sum, count).

Obs: usando IEnumerable, com where, ao atender a condição ele já termina, enquanto o to list ele
precisa carregar tudo na memória.

Se você precisa realizar uma unica consulta nos dados, sem precisar ficar acessando o resultado varias vezes
pode usar o IEnumerable. (se precisar modificar os dados é melhor usar o List)

List<T> e principais métodos de consulta LINQ

Any() - Determina se um elemento de uma coleção existe ou atende uma condição - (verificar se tem elementos)

FirstOrDefault() - Retorna o primeiro elemento da coleção que satisfaz uma condição opcional.
Retorna o valor padrão do tipo caso não encontre nenhum elemento.

Orderby() - Classifica os elementos em ordem crescente com base em uma determinada condição e
retorna a coleção classificada.

ToList() - Recebe um tipo IEnumerable e converte em um tipo list.

Where() - Retorna todos os elementos da coleção que satisfazem uma determinada condição. (retorna
um IEnumerable).


Indexadores

- Permite que as instancias de um classe ou struct sejam  indexadas como um array. Lembram
as propridades mas seus assessores get, set, recebem parametros.

permite acessar uma variavel de membro da classe ou struct usando recursos de uma array.

declarando um indexador

public int this[int index]
{
    get{}
    set{}
}

modificador de acesso + valor de retorno (não pode ser void) +  nome do indexador this + lista de parametros
de entrada em conchetes []

Se você quer criar um objeto que se comporte como um array/lista, use indexadores!

Classe Random

usada para gerar numeros pseudo aleatorios. O construtor sem parametros da classe Ramdom usa relogio
do sistema para gerar os valores de semente.

metodos da classe Random

Next() -----------retorna um numero inteiro positivo (dentro do intervalo padrão int)
Next(int) ---------- retorna um numero inteiro positivo que é menor que o valor maximo definido
Next(int, int) --------------- numero inteiro dentro de um intervalo
NextDouble() ------ numero ponto flutuante maior que 0,0 e menor que 1,0
Next(byte[]) -------------preenche elemento de um array de bytes com numeros aleatorios
NextInt64(...) Retorna um numero inteiro aleatorio positivo dentro de um intervalo 16 bytes - inicio 0


    









