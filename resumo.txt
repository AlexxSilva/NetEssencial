
Basico C#

Tipos de dados (Valor x Referência) - C# Linguagem fortemente tipada

Valor:

Variaveis do tipo valor não podem conter o valor null 
Os dados são armazenados na stack (Numericos: int, float, decimal)
								  ( Não numericos: bool, char, enum, datetime (struct))

estrutura de herança

System.Int32
   ↓
System.ValueType
   ↓
System.Object


Referência: 

Os dados fica armazenado na heap e cada variavel contem uma referencia ao local
onde os dados estão armazenados - Ponteiro para onde o dado está armazenado (string, object, class, dynamic).


Definindo variaveis ou constantes : Definir tipo, nome e atribuição de valores. (const - constantes)

Constantes: não podem ser alterados
variaveis : podem ser alteradas
(o tipo define o tamanho que a variavel usa de memoria.)

tipos valores:
//byte - 1 byte
short -  2 bytes
int -    4 bytes
float -  4 bytes
lont -   8 bytes
double - 8 bytes
decimal - 16 bytes (usado para valores financeiros)

Tipos strings são imutaveis, ou seja não podem ser alteradas. 
Quando concatenar ou passar valor ele cria um novo espaço de memoria.
(usar stringBuilder)

Tipo object é genérico, ele aceita qualquer tipo de dado pois todos os tipos herdam de object.
dynamic (semelhante ao object, mas é util para usar recursos como reflaction ou linguagem dinamica). 
(Todos os objetos herdeam de object)

Nullable types

Tornar um tipo de valor um tipo que aceita valor null.
int valor = null; (erro não é permitido) - tipo não anulavel
Nullable<int> valor = null; (aceita) - é um nullable type
int? valor = null;

nomenclaturas

PascalCase - primeira letra maiscula, e a letra de cada palavra seguinte maiscula.
usado em classes, métodos, interfaces e propriedades (entityframework, usa essa estrutura
pra criar os campos de tabelas).

CamelCase - primeira letra minuscula, e a letra de cada palavra seguinte maiscula.
(usado em variaveis, parametros e campos internos privados).

snake_case - primeira letra minuscula,  a letra de cada palavra seguinte minuscula,
com _ antes. (banco de dados).

(formas de juntar textos - concatenação, interpolação ($), placeholders usando chaves para dizer a ordem
que vou colocar os valores e depois virgula as variaveis.)

Sequencia de Escapes (\b - backspace, \n - nova linha, \\ barra invertida \? interrogação).

A linguagem c# é estaticamente tipada em tempo de compilação, ou seja depois que uma variavel é 
declarada, seu tipo não pode mais ser alterado ou usado para armazenar outro tipo de dado,
mas pode ser convertido para outro tipo desde que seja convertivel para outro tipo de dado. 

conversão implicita - o compilador faz automaticamente se ele entender q é conversivel
conversão explicita - feita de forma manual

conversão de strings (ToString())
Como todos os objetos herdam de object, todos os objetos herdam o método ToString

conversões também podem ser feitas com o uso da classe convert.

conversão de ampliação ou estreitamento entre dois tipos de dados tem exito se não houver perda de dados,
caso perca de dados o erro é OverflowException

Operadores aritméticos
+ - / * (% resto da divisão) 

Uso da classe Math para calculos matematicos.

inferencia de tipos (Tipo padrão é o tipo explicito)
Declaração do tipo implicito com var (deve ser definido o valor para que o compilador possa inferir o tipo de dados)
Não é possivel atribuir null.
multiplas variaveis do tipo implicito não podem ser inicializadas na mesma instrução.
não podemos alterar o tipo da variavel depois de inicializada.

quando usar var
tipos anonimos, laços for e foreach, instruções using

operadores de atribuição
=
+=
-=
*=
/=
%=

operador + e += com strings (concaterna) - null representa uma string vazia

constantes 
valores imutaveis que são conhecidos em tempo de execucao e não mudam durante a vida util do programa.


Incremento e decremento ++ e --

pos incremento  x++ (primeiro resolve a expressão depois incrementa - o valor da expressão fica sem o valor do incremento)
pre incremento ++x (incrementa e depois resolve a expressão)


operadores relacionais

==
>
<
>=
<=
!=

operadores logicos
&& - and
|| - or
! - not (negação)

ordem de precedência e associatividade
* , /, %, + , - [], ()

!, &&, ||

++, --, *, -

nullable referente types
Tipos de referencia que não tem referencia nenhuma (null)

lembrando que tipos valor são armazenados na stack, e tipos referencia é armazenado
na stack uma referencia para onde os dados estão armazenados e armazena na heap.

Quando o tipo referencia e nulo,eu não tenho essa referencia para o dado na heap,
pois não tem nada armazenado la.

string nome = null; (converting null literal or possible null value to non-nullable type)
nome.toUpper() - System.NullReferenceException 'Object reference not set to an instance of an object'

Nullable reference types  - nos alerta sobre a possibilidade de ocorrer um erro
envolvendo manipulação nula. Tem a finalidade de minimizar a chance de aplicativo lancar
um System.NullReferenceException

definir no arquivo de projeto : <Nullable>enable</Nullable>

(null condicional operation .? ou Nullable<T>)

string? nome = null;
nome?.ToUpper();

Estruturas de controle
IF / IF ELSE / IF ELSE IF / SWITCH / ESTRUTURA DE REPETIÇÃO / WHILE / FOR / DO WHILE / BREAK E CONTINUE

Classes e métodos

Classe : Tipo de referência, estruturado que contém os membros:  (atributos - propridades e campos ) (metodos - comportamentos)

Uma classe é uma abastração de um objeto do mundo real.

ex: Pessoa - atributos - nome, idade, sexo - metodos - Comer, andar, caminhar

Atravês da instancia da classe podemos criar objetos do tipo pessoa. (new)

obs sobre uso de memoria

Quando criando um objeto, a variavel é armazenada na stack, e o objeto é armazenado
na heap, onde a stack guarda a referencia para onde o dado está armazenado na heap.

caso eu crie outro objeto e ele recebe o primeiro objeto, os dois apontam para a mesma referencia 
na heap, ou seja se alterar as informações de 1 o outro também altera.

Objeto - Instancia de uma classe, criada pelo operador (new)

Objetos possuem caracteristicas proprias de algo do mundo real,
enquanto a classe descreve todos os objetos de um tipo particular.

métodos

Representa o comportamento das classes, e executam ações e realiza a comunicação entre objetos
contem	 um bloco de codigo com instruções que serão executadas quando forem chamadas.

Metodo main é o ponto de entrada para todas as aplicações  e é chamado pelo CLR (Common language runtime)
quando o programa é iniciado.

Funções são declaradas fora de uma classe, no caso em c# não existe pois os blocos de codigo
sempre são declarados dentro de classes, e nesse caso são metodos.

tipo de retorno + Nome (pascal case) + Lista de parametros +  Corpo do método

Ao tentar chamar os métodos da classe, vc perceberá mais métodos que você não criou, porque todas
as classes herdam de object, e na classe object que elas foram criadas.

Quando o método tem apenas uma instrução, eu posso usar um formato de expressão compacto

ex: 

 public void ExibirDataAtual()
{
   MessageBox.Show(DateTime.Now.ToShortDateString());
}

alterar para 
   public void ExibirDataAtual() =>
            MessageBox.Show(DateTime.Now.ToShortDateString());

passagem de parametros

 public void Saudacao(string nome , string data) 

contrutores

São tipos especiais de metodos usados para criar e inicializar objetos de uma classe. Sempre
que uma classe é instanciada, o contrutor é chamado.

Ao criar  uma classe, um construtor padrão sem parametros é criado automaticamente,
e ele é usado para criar uma instancia da classe e definir valores padrão para os membros da classe.
Ao instanciar a classe o contrutor padrão atribui os valores padrão aos membros da classe.


contrutores tem o mesmo nome da classe e não possuem retorno (podem possuir parametros para 
inicializar os membros da classe.)

eu posso ter mais de um contrutor e também posso chamar um contrutor em outro para passar os valores 
já preenchidos.

ex:
// esse contrutor chama o contrutor com dois parametros
public Aluno(string nome, int idade, string sexo, string aprovado) : this(nome, idade)
        {
            Sexo = sexo;
            Aprovado = aprovado;
        }

        public Aluno(string nome, int idade)
        {
            Nome = nome;
            Idade = idade;

        }

Palavra chave This -Referece a instancia atual da classe.
passar parametro da instancia atual para outros métodos.
invocar outro contrutor da mesma classe.
também é usada  como um modificador do primeiro parametro de um modo de extensãõ ???

Métodos com retorno (return)

Assinatura do método leva o nome do parametro, numero de parametros, tipo de parametro, ordem dos parametros

não é possivel ter dois métodos iguais, mas com o mesmo nome sim desde que uma das opcoes acima seja
diferente.

Passando argumento por valor e por referencia

Valor: Uma copia do valor do argumento é feita e passada para o parametro do método chamado
Referencia: Passa a referencia ao mesmo local da memória dos argumentos, nenhuma copia
é passada, dado ao método a capacidade de acessar e modificar a variavel original do chamador.

Usa as palavras ref ou out.

diferença out x ref
out transfere os dados para fora do método e nao para dentro dele
variaveis no argumento out não precisam ser inicializadas antes de serem passadas em
uma chamada de metodo, no entanto o método chamado deve atribuir um valor ao parametro
definido com a palavra-chave out antes que  método seja retornado.

parametro: o valor que  método espera receber quando for chamado
argumento: representa o valor que você passa para o parametro

argumentos nomeados, eu passo o argumento pelo nome dos parametros e não pela ordem que foram
colocados.

parametros opcionais
permite definir parametros que o chamador pode omitir. (precisa ter um valor padrão na sua definição,
pois se nenhum argumento for enviado para esse parametro, o valor poderá ser usado.)

metodos estaticos (static)
(classes, interfaces, structs, campos, métodos, propridades, operadores, eventos, contrutores).

Esses métodos não dependem da criação e instancia do objeto para serem acessados. 
Classe.metodostatico(parametros)
métodos estaticos não possuem ligação com um objeto, eles não podem usar variaveis de instancia,
que são variaveis de objeto.

campos staticos (campos e propriedades) - pertencem a classe e podem ser acessados sem o new

armazenamento Stack x heap

Quando um objeto é instanciado, a referencia do objeto é guardada na stack, e as informações guardadas
na heap. No caso de campos estaticos, eles são guardados direto na heap, e cada objeto armazenado na
heap compartilha a mesma referencia ao campo estatico.

Contrutor statico - inicializar qualquer membros estaticos  ou para executar uma ação especifica que
precisa ser executada apenas uma vez.

ele é chamado automaticamente antes que a primeira instancia seja criada ou que quaisquer membros
estaticos seja referenciados.

Um contrutor estatico nao usa modificadores de acesso, nem tem parametros
Uma classe ou struct só pode ter um unico contrutor statico.
um contrutor statico não pode ser chamado diretamente
O usuario não tem controle sob quando o contrutor statico é executado no programa
inicializa com o valor padrão quando não inicializado
se gerar uma exceção, o runtime nao invocara uma segunda vez e o membro estatico permacerá
não inicializado durante o tempo de vida od projeto.

Propriedades // a abordagem se acessar as variaveis publicas seja pela instancia da classe ou 
pela propria classe diretamente sem restricao viola um dos paradigmas da orientação a objetos
que é o encapsulamento.

As propriedades foram criadas para resolver esse problema.

Uma propridade é um membro de classe que fornece um mecanismo para ler, gravar e calcular o valor
 de um campo privado.
Podem ser usadas como membros publicos, mas possuem metodos especiais chamados de acessadores (get set)
os acessadores permite que os dados sejam acessados com facilidade e ainda ajuda a promover a segurança
e a flexibilidade dos métodos.
A propridade permite que uma classe exponha uma maneira publica de obter e definir valores, enquanto
oculta o codigo de implamentacao ou verificaçao.

get - retorna o valor do campo privado
set - permite realizar alguma validacao de dados antes de atribuir um valor ao campo privado.
//propriedades leitura e gravação,  somente leitura, somente gravação.

leitura e gravacao 
public string? Nome { get; set; }

somente leitura
public string? Nome {get;}

somente gravação

private nome;
public string? Nome
{
    set { nome = value; }
}


Structs
É um estrutura semelhante a classe, composta por tipos de dados e funcionalidades (metodos,
constantes, contrutores, propriedades, indexadores, operadores e outros tipos de estruturas)

Structs são do tipo valor, e não referencia (são armazenados na stack)

struct name
{
}

diferença de struct e classe em relação a memoria

structs c1 e c2
c1.valor = 1;
c2 = c1; (nesse momento os dados das duas structs estão armazenados na stack, e duplicado o valor)

stack
c1 ==== valor =1
c2 ==== valor =1

classes c1 e c2
c1.valor = 1;
c2 = c1; (nesse momento a referencia da memoria na stack das duas classes apontam para o mesmo espaço alocado na heap)

stack                            heap
c1 ==== ref = c1---------------- mesmo espaço
c2 ==== ref = c2---------------- de memoria (valor = 1)

quando usar struct 
Instancias do tipo pequena e de curta duração ou se forem comumente incorporadas em outros objetos.

evite definir uma struct a menos que:
Represente logicamente um unico valor, semelhante a tipos primitivos.
Tenha uma tamanho de instancia inferior a 16 bytes.
é imutavel
Não precisa sofrer conversão para tipos referencia (boxing) - com frequencia

Enum ou enumeration (tipo valor, memória stack)

tipo de de dado especial definido pelo usuario, é um conjunto de constantes nomeadas do tipo numerico
que torna o programa mais facil de entender.

pode ser feita diretamente dentro de um namespace,  classe ou struct.

por padrão os membros de uma enum são do tipo int; o primeiro tendo o valor 0, e restante icrementado de 1.

o enum pode ser acesso por nome

modificadores de acesso

palavras para especificar o acesso a um membro (campo, propriedade,metodo) ou tipo (class, struct, etc)

public - pode ser acessado por qualquer outro codigo no mesmo assembly, ou outro assembly.

private -   so pode ser acessado por outro codigo na mesma classe ou struct

internal - pode ser acessado por qualquer codigo no mesmo assembly.

protected - pode ser acessado própria classe e qualquer classe derivada dela (mesmo em outro assembly/projeto).

protected internal - A própria classe e classes derivadas e qualquer código dentro do mesmo assembly.

file (C#10) - Restringe o escopo e visibilidade de um tipo em nivel superior ao arquivo no que ele foi declarado.

estratégia - limitar a visibilidade de seus tipos e ou membros, restringindo-os a apenas a quem
precisa realmente acessar o tipo ou membro.

tratamento de erros (try catch)
trata exceções, erros encontrados em tempo de execução do programa
se o sistema não tratar a excessão o sistema para a execução do programa com a mensagem do erro.
finally - outro bloco que será executado ao dar a exceção para liberar os recursos usados ao realizar outra tarefa.

propridades da exceção

Message - mensagem explicando o erro da exceção
StackTrace - descreve onde ela ocorreu
InnerException - se a exceção for lançada por outra exceção, contem a referencia da antiga exceção.

Tipos anonimos T (3.0 C#)

Fornecem uma maneira conveniente para encapsular um conjunto de propriedades, somente leitura
em um unico objeto sem precisar definir explicitamente o tipo.

O nome do tipo é definido pelo compilador e não está disponivel no codigo fonte e o tipo de cada
propriedade é inferido pelo compilador.

inicializado com new combinado com inicializador de objetos.
a palavra chave var recupera a referencia do objeto 

são derivados de object

var aluno = new 
{
    Nome = "Maria",
    Idade = 42
};

tipos anonimos são somente leitura.
tipos anonimos permitem propriedades anonimas


var aluno = new 
{
    Nome = "Maria",
    Idade = 42,
    Endereco = new {Id= 1, Cidade = "SP"}
};

//utilidade
normalmente são usados em uma clausula select de uma expressão de consulta geralmente
com linq, para retornar um conjunto de propriedades de cada objeto na sequencia da origem.

Partial class
Permite que uma classe venha a ser implementada em multiplos arquivos fisicos com extensão cs.
(classes parciais podem usar mais de um arquivo cs e ser a mesma classe)
podemos criar classes, interfaces, structs e metodos parciais com o modificador partial

Eu posso ter duas classes parciais com o mesmo nome, separadas em arquivos cs diferentes,
o compilador irá entender que é a mesma classe.

regras
classes parciais devem estar no mesmo assembly
mesmo nivel de acessibilidade
atribuitos são para todas as partes da classe

quando usar
grandes projetos, permite que varios programadores trabalhem ao mesmo tempo
codigos gerados automaticaamente, o codigo pode ser adicionado a classe sem precisar recriar o arquivo
de origem
ao usar geradores de codigo fonte  para adicionar uma funcionalidade adicional a classe

====================================================================================

arrays e coleções



arrays - numeros fixo de opcoes do mesmo objeto
coleções - uma maneira flexivel de trabalhar com grupos de objetos

Coleções não genéricas:System.Collections

ArrayList, SortedList, Queue, HashTable

Genéricas: System.Collecions.Generic (indicadas, melhor desempenho)

List, SortedList, Queue, LinkedList, HashSet, SortedSet, Dictinary, SortedDictionary

==================

Arrays (usado para armazenar mais de um valor literal do mesmo tipo em uma variavel do mesmo nome)

Conjunto do mesmo tipo de dados e de tamanho fixo.
Uma dimensão: Vetor

__ __ __ __ __ __

mais de uma dimensão: Matriz (abaixo de duas dimensões - linhas e colunas)

__ __ __ __ __ __
__ __ __ __ __ __
__ __ __ __ __ __
__ __ __ __ __ __

declaração 

int [] lista = new int[3]{1,2,3};

sintaxe simplificada

 string[] nomes2 = { "Alex", "Jeniffer" };

 cada elemento é um indice, que começa do 0. No caso acima o indice 1 contem o valor "Jeniffer"

 arrays são armazenadas sua referencia na stack, e os dados na heap (também são objetos)

 //percorrer arrays (for, while, do while) usando o contador como indice no array
 A classe array está no namespace system e fornece algumas propriedades para trabalhar,
 como length, rank, copy, Clear, Sort, etc).
com o foreach é possivel percorrer sem usar o indice e definir o tamanho do array.

Classe Array (metodos para trabalhar com arrays)

Array.Reverse(nome_array) inverter a sequencia
Array.Sort(nome_array) Ordenar
Array.BinarySearch(nome_array, objeto) - busca em um array um valor, atraves do algoritmo
de busca binaria. retorna o indice do valor, ou negativo se não encontrado.

Array como parametros de métodos (params)

aceita como argumento valores separados por virgula,e converte em array.
Ex:

void calcSoma(params int[]numeros)
{
}

posso passar como valor:

calcSoma(1,2,3,4,5,6)

params não pode ter outro parametro no método antes dele. Só ele ou ele por ultimo.

Arrays dimensionais

suporta até 32 dimensoes

arrays bidimensionais são como se fosse tabelas (linhas e colunas)
int[,] numeross2 = new int[3,3];
int[,]a = { {0,1}, { 2,3 } };

Array bi dimensional - laço for
usar o laço for para ler e recuperar os elementos do array bidimensional
getLength(0)

//for com array
            int[,] n = new int[2, 3] { { 1, 4, 2 }, { 3, 6, 8 } };

            for (int i = 0; i < n.GetLength(0); i++) // primeira dimensão linhas
            {
                for (int j = 0; i < n.GetLength(1); i++) // segunda dimensão colunas
                {
                    
                }
            }

// com foreach - percorre os elementos de forma crescente de indice começando do zero até lenght -1.
 foreach (int i in nz)
            {
                
            }

//arraylist
coleção não generica que armazena elementos de varios tipos
Essa coleção é uma alternativa a array e também pode ser indexada individualmente e permite
alocação dinamica de memoria, inclusao, pesquisa e classificacao de elementos de coleção.

namespace System.Collection

ArrayList() - usado para criar uma instancia de classe ArrayList, que está vazia e sem capacidade
inicial. (capacity e count)

ArrayList(int32) - usado para criar uma instancia de classe ArrayList, que está vazia e TEM capacidade
inicial especificada

ArrayList(ICollection) - usado para criar uma lista de Array, com elementos de uma coleção especifica
e tendo a mesma capacidade inicial que é copiado da seleção.

criar NEW, e adicionar com Add

capacity e count (aumentam conforme eu adiciono elementos na lista se for criado um array list sem parametros)
permite qualquer tipo de dados

inicializadores de objetos (object inicializer) -inicializar em uma unica etapa

Add - permite adicionar um elemento no final do arraylist
insert(int index, Object value)
lista.Add("Alex");//adiciona no final
lista.Insert(2, "Jeniffer"); //adiciona na posicao 2 e realoca os outros elementos

//posso incluir uma coleção no final ou em uma posição do arraylist, realocando os outros elementos
list.AddRange(array1); //adicionar lista
list.InsertRange( 2, array1 ); //adicionar lista realocando


remover
Remove (Object value)
removeAt (index)
RemoveRange (int index, int count)
lista.Remove(null);//vai remover a primeira ocorrencia que tiver como null
lista.Remove("Maria");
lista.RemoveAt(1); //remove o da posição index 1
lista.RemoveRange(0, 2); // remove começando da zero e duas posicoes

//verificar se existe na arraylist
.Contains() retorna true ou false.

//ordenar
.Sort (usa o Quicksort)

//remover toda a lista (limpar)
.Clear()

Por ser um tipo Object, o desempenho dele não é bom, pois todos os itens ficam como object,
e tem que ser convertido pro tipo correto. (boxing e Unboxing) - conversão tipo de valor para objeto,
e objeto para valor.

Boxing - Conversão do tipo Value Type , para Reference Type
Unboxing - conversão do tipo Reference Type para Value Type 
(essas operacoes diminuem o desempenho da lista)
Parse - converter uma string para um tipo especifico.
Cast - converter um tipo objeto para um tipo espefifico (que já é compativel)

A recomendação é usar é usar a coleção List<T>

Coleção LIST

A coleção List<T> é uma coleção de objetos fortemente tipados que podem ser acessados usando 
indice que inicia em zero, e possui métodos para classificar, pesquisar, modificar, e manipular listas.
É uma versão genérica da ArrayList, sendo equivalente, em caracteristicas, com mais performance.

a classe list<T> podem ser usadas para criar coleções de tipos diferentes, onde T representa o tipo
do objeto que pode ser inteiro, string, double,etc. e também pode ser um tipo complexo com a classe
definida pelo usuário.

pode conter elementos do tipo especificado T, faz a verificação do tipo em tempo de compilação
e não faz boxing e unboxing pois é genérica.

podem ser adicionados usando elementos: add(), addRange(), Insert(), InsertRange(), ou usando
a sintexe de inicializador de coleção.

Uma List<T> é dinamica e pode ser redimencionada.

Uma List<T> inicia vazia e seus elementos são alocados sob demanda.

São tipo referencia: uma variavel refere-se a um objeto real, que deve ser armazenao na memoria heap

para criar um list<T> temos que especificar o tipo e usar a palavra NEW
podemos usar add para incluir elementos ou usar inicializadores de coleção para criar uma list<T>
em uma unica etapa.

tem os mesmos metodos da classe arralist (Add, insert, AddRange, InsertRange, sort, clear, remove)
da pra percorrer com for e foreach, acesso aos elementos pelo indice.
uso do contains para saber se está na lista.

List<T>
System.Collections.Generic
Coleção de objetos fortemente tipados
Não realiza operação boxing e unboxing
Apresenta melhor desempenho
Apresenta segurança de tipo
Recomendado para tratar objetos homogeneos e heterogenios

ArrayList
System.Collection
Coleção que pode armazenar itens de diversos tipos de dados. Não é fortemente tipada
Realiza operação boxing e unboxing
Apresenta um desempenho menor
Não apresenta segurança de tipo
Seu uso deve ser evitado.

//metodos Find da List<T>
Find (primeiro elemento que corresponde a um predicado fornecido),
FindLast (ultimo elemento), FindIndex, FindLastIndex, FindAll (Coleção de elementos que corresponde a um predicado)

Um predicado é uma função/metodo de argumento unico (condicao) - critério que retorna um valor booleano.

os métodos Find esperam um predicado (metodo ou função que retorna um bool) ex:

List<string> frutas = new() { "Uva", "Banana", "Pera", "Maça", "Abacate", "Laranja", "Morango" };

var fruta = frutas.Find(Procura);

 static bool Procura(string item) // o parametro do metodo procura é cada elemento do list, pra saber algum inicia com L
{
   return item.StartsWith("L");
}

ao inves de passar um método eu também posso passar uma expressão lambda (paradigma funcional)

Expressão lambida - é uma função anonima, ela não tem nome
os parametros de entrada tem que estar do lado esquerdo do operador  =>
e definir a expressão ou bloco de instruções do lado direito.

x => x * x;

var fruta2 = frutas.Find(f => f.Contains('n'));


List<T> x IEnumerable

- IEnumerable é uma interface (descreve um comportamento) - List implementa a interface IEnumerable.
- IEnumerable é somente leitura
- List Implementa uma variedade de métodos capazes de acessar e alterar a coleção.
- IEnumerable possui um método para retornar o próximo item da coleção
  Não precisa ter toda a lista em memória
  Não sabe quantos elementos a coleção possui
  Ao ser iterada em um laço foreach ele vi retornando o proximo item até o fim da coleção

- List possui toda a coleção em memoria e sabe quantos itens possuem a coleção. (A coleção já é numerada)

-IEnumerable da ao compilador a chance de adiar a execução (deferred execution), somente é executada ao ser
iterada em laço foreach/for, ou ter o valor extraido (sum, count).

Obs: usando IEnumerable, com where, ao atender a condição ele já termina, enquanto o to list ele
precisa carregar tudo na memória.

Se você precisa realizar uma unica consulta nos dados, sem precisar ficar acessando o resultado varias vezes
pode usar o IEnumerable. (se precisar modificar os dados é melhor usar o List)

List<T> e principais métodos de consulta LINQ

Any() - Determina se um elemento de uma coleção existe ou atende uma condição - (verificar se tem elementos)

FirstOrDefault() - Retorna o primeiro elemento da coleção que satisfaz uma condição opcional.
Retorna o valor padrão do tipo caso não encontre nenhum elemento.

Orderby() - Classifica os elementos em ordem crescente com base em uma determinada condição e
retorna a coleção classificada.

ToList() - Recebe um tipo IEnumerable e converte em um tipo list.

Where() - Retorna todos os elementos da coleção que satisfazem uma determinada condição. (retorna
um IEnumerable).


Indexadores

- Permite que as instancias de um classe ou struct sejam  indexadas como um array. Lembram
as propridades mas seus assessores get, set, recebem parametros.

permite acessar uma variavel de membro da classe ou struct usando recursos de uma array.

declarando um indexador

public int this[int index]
{
    get{}
    set{}
}

modificador de acesso + valor de retorno (não pode ser void) +  nome do indexador this + lista de parametros
de entrada em conchetes []

Se você quer criar um objeto que se comporte como um array/lista, use indexadores!

Classe Random

usada para gerar numeros pseudo aleatorios. O construtor sem parametros da classe Ramdom usa relogio
do sistema para gerar os valores de semente.

metodos da classe Random

Next() -----------retorna um numero inteiro positivo (dentro do intervalo padrão int)
Next(int) ---------- retorna um numero inteiro positivo que é menor que o valor maximo definido
Next(int, int) --------------- numero inteiro dentro de um intervalo
NextDouble() ------ numero ponto flutuante maior que 0,0 e menor que 1,0
Next(byte[]) -------------preenche elemento de um array de bytes com numeros aleatorios
NextInt64(...) Retorna um numero inteiro aleatorio positivo dentro de um intervalo 16 bytes - inicio 0


====================================

Orientação a Objetos

Paradgma onde tudo é um objeto. Objetos se interagem uns com os outros para realizar tarefas.
Objeto é uma estratura que incorpora dados e comportamentos para  trabalhar com esses dados.

Um objeto é uma instancia de uma classe.
Onde classe é o tipo e objeto é uma instancia do tipo.

A classe é a entidade abstrata
o objeto é a materialização da classe.

pilares

Abstração : reduzir a complexidade e tornar o objeto e a implementação mais eficientes em sistemas
complexos. se concentra nos aspectos essenciais de um contexto qualquer, ignorando caracteristicas
menos importações.

Encapsulamento: não permitir o acesso  direto aos dados do objeto. (protegido)
O codigo do objeto deve controlar o seu estado, sendo alterado pelo seus proprios metodos (segurança da classe)
    
Herança: Novas classes podem reutilizar, estender e modificar o comportamento definido em outras classes.

A classe cujo os membros são herdados é chamada de classe base, e a classe que herda esses membros é chamada
de classe derivada.

A Classe base fornece uma funcionalidade comum e as classes derivadas herdam ou subistituem essa funcionalidade.

Polimorfismo: Objetos distintos respondem a mesma mensagem de sua propria maneira.
Podemos invocar metodos da classe derivada (subclasse) atraves da classe base (superclasse), em tempo de execução e permite
que classes fornecam diferentes implementacoes de métodos que são chamados com o mesmo nome.

--------------------------------------------------------

herança : apenas herança simples (hierarquia de heranças)

(Reutilização de código, Especialização (permite atributos especificos e compartilhados da classe base,
permite hierarquia de classes , flexibiel e escalavel.), 
extensibilidade - permite adicionar novos comportamentos e atributos as classes derivadas,
sem modificar a classe base)., encapsulamento - proteção do codigo)

possiveis problemas: 

Alto acoplamento de classes (muito cuidado)
Heranças profundas podem levar a complexidade e tornar o codigo menos legivel.
reutilização excessiva.
rigidez, necessidade de mudar ajustar todas as classes derivadas caso tenha uma alteração na classe base.

Não esquecer de usar o encapsulamento das variaveis usando propriedades.

contrutores de classes herdadas.

A classe base e a classe derivada podem ter seus proprios construtores, a classe derivada não herda
o contrutor da classe base mais pode invoca-lo.

//o contrutor da classe base é executado primeiro, e depois do classe derivada ao instanciar classe derivada.

quando eu quero chamar um contrutor especifico da classe base eu uso "base"

ex:
classe Pessoa com dois contrutores 

        public Pessoa()
        {
            Console.WriteLine($"Contrutor da classe pessoa");
        }
        public Pessoa(string Nome)
        {
            Console.WriteLine($"Contrutor da classe pessoa com parametros");
        }
a classe derivada Aluno, invoca o contrutor que foi especificado como base.

public Alunos() : base() // vai invocar o contrutor sem parametros da Classe Pessoa primeiro
        {
            Console.WriteLine($"Contrutor da classe aluno");
        }
        public Alunos(string nome) : base(nome) // vai invocar o contrutor com parametro da classe PEssoa primeiro
        {
            Console.WriteLine($"Contrutor da classe aluno com parametros");
        }

Herança com relação a object

Toda classe é derivada de object (Classe base de todas as Classes)
Os metodos definidos na classe object estão disponiveis para todos os objetos do sistema.

Equals - Suporta comparações entre objetos
GetHashCode - Gera um numero hash para o objeto
ToString - Retorna a representação do objeto como string
GetType - retorna informação sobre o tipo

Se um membro da classe derivada tiver o mesmo nome do membro de uma classe base, o compilador
notifica que o metodo da classe derivada está ocultando o método da classe base.
. O modificador new remove o aviso do contrutor, deixando explicito que quer isso mesmo.

(uso do new na classe derivada)
  public new string Saudacao() => $"Oi seu sou {Nome}";

Uma outra forma também é substituir o membro com  mesmo nome da classe usando virtual e override.
Com ele é possivel sobrescrever a classe, mudando sua implementação.
O virtual significa que esse metodo da classe base pode ser sobrescrito nas classes derivadas.

Sealed

Quando aplicado a uma classe, o modificador sealed, impede que outras classes herdem dela.

sealed class MinhaClasseBase // não é possivel herdar essa classe
{

}

o mesmo para os métodos

sealed protected void carregar1(); // esse não pode

override protected void carregar2(); // esse pode usando o virtual

Herança - relacionamento "É um" entre classe base e uma ou mais classes derivadas.

Classe base
     ↑
     | é um
     |
Classe derivada

A classe base é uma generalização das suas classes derivadas

herança simples (uma classe base e uma classe derivada)

herança hierarquica - varias classes derivadas para uma classe base.

herança Multinivel - Ocorre quando uma classe derivada de outra classe derivada.
classe C herda da B que herda da A

herança multipla - uma classe herda de varias classes (no C# as classes não permitem herança multipla,
somente é possivel assinando contratos - interface.
)

Downcasting e upcasting

upcasting (implicita)- converte um objeto de um tipo especializado (classe derivada) para uma classe base.
Ex:
Classe Conta e classe derivada ContaSalario
ContaSalario contaSalario = new ContaSalario();
Conta conta = contaSalario; agora conta é igual conta salario, mas se tiver um metodo especifico
da classe conta salario, em conta ele não vai poder ser acessado.

Downcasting explicita - operação inversa objeto do tipo geral para um tipo especializado.
Essa operação pode falhar retornar uma excessão.

ContaSalario conta = (Conta)conta; // aqui volta a ter acesso ao metodo da classe conta salario.

Operadores is e as

O operador as é usado para realizar a conversão entre tipos referência ou tipos anuláveis compativeis
retorna o objeto quando é compativel com o tipo de dado e retorna null se a conversão não for possivel
ao invés de gerar uma excessão.

A conversao var x = (string)Funcionario; retorna uma exception system.InvalidcastExeption
com o as, ele retorna null ao inves de uma exeption

  Funcionario? f2 = p as Funcionario; // com o operador se não converter retorna nulo

            if (f2 != null) {
            {
               f2.ListarFuncionario(); // pessoa voltar a ser o funcionario
            }

operador is é usado para verificar se o tipo de um objeto é compativel com o tipo especificado
ou não, retorna true se o objeto for do mesmo tipo, caso contrario retorna false.
Retorna false para objetos nulos.

podemos usar para saber se uma conversão de tipos é bem sucedida

Funcionario f = new Funcionario();
Pessoa p = f;

if (p is Funcionario) // saber se são compativeis
{
 Funcionario? f2 = p as Funcionario; // com o operador se não converter retorna nulo
 f2?.ListarFuncionario();  poderia usar o if pra saber se é nulo
}

Abastract

O modificador abastract indica que o recurso que está sendo modificado
tem uma implementação ausente ou incompleta.

Ele pode ser usado com classes, métodos propriedades, indexadores, eventos

Uma classe abastract, indica que ela está apenas sendo uma classe base de outras classes,
nao podendo ser instanciada.

Membros marcados com o modificador abstract devem ser implementados por classes não abstratas
que derivam de uma classe abstrata.

Um metodo abstrado nao possui implementação na classe abstrata, somente na classe derivada
Um método abstrato possui somente a definição de sua assinatura
um método abastrato é implicitamente um metodo virtual
é um erro usar modificadores virtual e static em métodos abstratos
propriedades abstratas se comportam como métodos abstratos.

Interface (contrato entre si e com qualquer outra classe que implementar)

antes do C# 8.0 - até 2019 era como uma classe base abstrata que continha apenas membros
abstratos e qualquer classe ou struct que implementa-se uma interface deveria implementar
todos os seus membros.

C# 8.0- pode definir implementações padrão e não precisa implementar todos os membros que
tenham uma implamentação padrão.

C# 11 - Os membros que nãõ são campos podem ser static abstract

Pode conter assinaturas de métodos, e também podem conter métodos publicos
e estaticos que contenham implementação.

podemos alterar os modificadores da classe.

não tem: campos de instancia, construtores de instancia, ou finalizadores.

para implementar um membro da interface, na implementação o membro deve ser publico
nao estatico e ter o nome e assinatura do membro da interface.

não podem ser instanciadas diretamente
pode herdar de uma ou mais interfaces, tendo que implementar todos os membros abstratos,
herdando todos os membros da interface base.

Relacionamento entre classes (Composição e Agregação)

Relacionamento "É um" - Representado pela herança
Relacionamento "Tem Um" - Representado pela composição e pela agregação.

COmposição e agregação permitem que uma classe contenha um ou mais objetos de outras
classes para formar um grande objeto realizando funcionalidades especificas.
O container é a superclasse ou classe pai, e as classes contigas são sub classes, ou classes filhas,
possuindo um relacionamento "Tem um";

Composicao: Um objeto de uma classe é composto por um ou mais objetos de outras classes.
O relacionamento é formado quando uma classe tem uma referencia a outra classe como 
propriedade ou instancia.

diagrama de classes (composição)

Classe Pai               classe filha
                tem um
Classe A   ◆------------- ClasseB

Relação Todo(pai) - parte(filhas)
O todo(pai) é responsavel por criar e destruir as suas partes (filhas)
A parte(filha) não existe sem o todo (pai)
O mesmo objeto parte não pode se associar a mais de um objeto todo

Ex:

             "tem um"
Produto   ◆------------- Categoria
(Todo)                  (filha)

Pedido   ◆------------- ItensPedido
(Todo)                  (filha)


Assim como a herança, a composição permite reutilização de código.
Com a composição nós podemos reutilizar codigo no nosso projeto sem duplicar.

Agregação

Tipo especial de composição onde objetos de uma classe pode conter um ou mais 
objetos de outra classe.

                tem um
Classe A  ◇------------- ClasseB (losangulo vazio é agregação)

Na agregação a parte pode existir sem o todo

A agregação é uma associação mais fraca, enquanto a composição é uma associação mais forte.


nameof() - produz o nome de uma variavel,  tipo ou membro como a constante da cadeia de caracteres, em
outras palavras exibe o nome da variavel.


Polimorfismo

Polimorfismo é o principio, pelo qual duas ou mais classes derivadas de uma mesma superclasse
podem invocar métodos que tem a mesma identificação (assinatura), mas comportamentos
distintos especializados para cada classe derivada, usando para tanto uma referência a um objeto
do tipo da superclasse.

- invocar metodos da classe derivada atraves da classe base,
diferentes implementações de metodos que são chamados com o mesmo nome.

Tipos de polimorfismo

Em tempo de compliação (Overloading ou sobrecarga)
Sobrecarga de métodos e operadores, chamado de ligação precoce(erly binding).


Em tempo de execução (Overrinding ou Sobrescrita)

Pode ser feito usando herança e métodos virtuais. (override - late binding ligação tardia)
Invocar métodos da classe derivada através de classe base em tempo de execução.

 ====================================================


 
 Generics

Não ser especifico para um determinado tipo de dados
permite definir classes, interfaces, campos, métodos, propriedades, eventos,
delegates e operadores genéricos usando o parametro tipo e sem tipo de dados especifico.

sintaxe

<T>

definir restrições para restringir o tipo com where

NomeTipo <T> where T: <restrição>

public class ClassGeneric<T> where T: struct ---- determina que tem q ser um tipo valor
public class ClassGeneric<T> where T: class, new() --- determina que tem ser um tipo de referencia com contrutor publico sem parametro
public class ClassGeneric<T> where T: class --- determina que tem ser um tipo de referencia 

Posso restringir com o nome de uma classe base, ou interface (obriga a implementar a interface)

beneficios: segurança de tipo, reutilizacao de codigo, desempenho (evita boxing e uboxing)

Generics é usado para definir as coleções genericas de System.Collection.Generic
Collection<T>, List<T>, Dictionary <TKey, TValue>
Queue<T>
Stack<T>

GetType() - retorna o tipo de dado no generics

o método com o <T>
public void comparar<T> (T1, T2);

Se estiver definido na classe, não precisa dizer que o método é generico 

 public class Teste1<T1, T2> where T1 : struct where T2 : struct
    {
        public bool Comparar(T1 p1, T2 p2)
        {
        }
    }

GetHashCode e Equals

são métodos da classe object que servem para comparação de objetos

GetHashCode - retorna um valor inteiro (codigo hash) - mais rapido que o equals
Equals - retorna um boolean (ao comparar dois objetos
mesmo que atribuido os mesmos valores se comparar retorna false, pois são
referencias a objetos diferentes)

Nos tipos definidos pelo usuário é necessario sobrescrever esses dois metodos
para garantir a igualdade entre dois objetos do mesmo tipo

Obs: GetHashCode pode gerar numeros iguais para objetos diferentes.

Coleções Genericas  x Não Genéricas

Não Genericas
ArrayList, HashTable, SortedList, Stack, Queue


Principais Caracteristicas

//Armazenam dados do tipo object, realizam boxing e unboxing, são suscetiveis a erros
em tempo de compilação por incompatibilidade de tipos.

Genericas

Dictionary, SortedDictionary, SortedList, LinkedList, hashSet, sortedSet,
Stack, Queue, List

são fortemente tipas, elementos de um unico tipo e não realizam boxing e unboxing

favorecem a reutilização de codigo

ArrayList .... List<T>
hashtable .... Dictionary<Tkey, Tvalue>
Queue ...Queue<T>
SortedList.... SortedList<T>
stack .... stack<T>

Dictionary

coleção do tipo chave valor (implementa a interface IDictionary) com duas coleções no seu interior
uma pra guardar a chave e a outra o valor  (chave exclusiva)

IEqualityComparer<T> usa um contrutor que aceita comparação (valor padrão usado caso não declarado)

Dictionary<TKey, TValue>

Dictionary<string, int> dic1 = new Dictionary<string, int>();
Dictionary<string, int> dic1 = new Dictionary<string, int>(5);

(a chave não pode ser repitida e nem nula)

propriedades

Count - Numero de elementos
IsReadOnly - retorna um bolean se o Dictionary é somente leitura
Item - obtem ou define o elemento com a chave
Keys - retorna a coleção de chaves
Values -retorna a coleção de valores
Comparer - Obtem o IEqualityComparer<T> que é usada para determinar a igualdade
de chaves para o dicionario

metodos
Add (Tkey, Tvalue) -adiciona chave e valor (erro ArgumentException)
TryAdd  (Tkey, Tvalue) - tenta adicionar, retorna true se deu certo
Clear() - Remove as chaves e valores
ContainsKey(Tkey) - determina se contem uma chave
ContainsValue(Tvalue) - determina se contem um valor
Remove(Tkey) remove os valores de uma chave especificada
TryGetValue (Tkey, Tvalue) - Obtem o valor associado a uma chave especifica, se não existir
retorna o valor padrão para o tipo de parametro value.
 if (dic2.TryGetValue(4, out int valor))
            {
                MessageBox.Show($"Valor {valor}");
            }
exibindo pela chave {dic2[7]} (7 é a chave)

percorrendo com foreach
 foreach (var item in dic2)
            {
                MessageBox.Show($"Valor {item.Key} - {item.Value}");
            }

Sorted Dictionary

SortedDictionary<TKey, TValue> (Colleção ordenada) (usa arvore binaria para manter os itens em ordem
pela chave) usa a interface IComparable <Tkey> de modo que as chaves possam ser corretamente ordenadas

tem os mesmos metodos da classe Dictionary

Coleções Set

Coleção que contem apenas itens distintos é conhecida pelo conjunto de termo set.

HashSet<T> contem uma lista não ordenada de itens distintos.
SortedSet<T> contem uma lista ordenada de itens distintos


HashSet<T> - Coleção generica e não ordenada que implementa uma interface ISet<T> e representa um conjunto
de itens exclusivos (não permite a inclusão de elementos duplicados)
usa uma função hash para determinar a posicao de um item na coleção, o que permite acesso rapido
aos elementos.

a ordem pode mudar quando adicionamos elementos ou removemos

A interface oferece metodos para criar  uma união de multiplos conjuntos , para criar intersecção de conjuntos,
ou para fornecer informações se um conjunto for um superconjunto ou subconjunto de outro.

var numeros = HashSet<int> {1,2,3,4};
var frutas = new HashSet<string> {"uva", "banana", "pera"}


var pares = new HashSet<int>();
for (int i=0; i<6; i++)
{
    pares.Add(i * 2);
}

posso também usar o construtir que eu passo um IEnumerable

var numeros = new List<int>(){1,2,3,4,5} // list que herda de IEnumerable
 var conjunto = new HashSet<int>(nums);  

 qualquer coleção que implementa a interface IEnumerable, pode ser usada como parametro no HashSet.

 propriedades

Count - Numero de elementos 
Comparer - Obtem o IEqualityComparer<T> que é usada para determinar a igualdade no hashset


métodos

padrões

Add
Contains
Remove

ExceptWith(IEnumerable<T>) - Remove todos os elementos na coleção especificada
IntersectWith(IEnumerable<T>) - Modifica o Hashset atual para q contenha apenas elementos presentes no objeto e na
coleção especificada.
IsSubsetOf(IEnumerable<T>) - Determina se uma coleção hashset é subconjuto de outra.
Overlaps(IEnumerable<T>) - Determina se um objeto atual e uma coleção compartilham elementos comuns.
RemoveWhere(Predicate<T>) - Remove todos os elementos que correspondem as condições definidas pelo predicado
especificado de uma coleção de hashset
SetEquals(IEnumerable<T>) Determina se um objeto e coleção contem os mesmos elementos
SymmetricExepctionWith(IEnumerable<T>) mdifica o Hashset atual para q ele contenha apenas elementos que estão
no HashSet atual, ou na coleção especificada, mas não em ambos.
UnionWith(IEnumerable<T>) - Modifica o hashset atual para que ele contenha todos os elementos que estão presentes
no hashset atual e em uma coleção especifica.


SortedSet<T> - mesmos métodos só que permite ordenar.

Stack<T> - pilha , O ultimo a entrar é o primeiro a sair.

push, pop , peek

Stack<T>, stack<T>(IEnumerable), Stack(int Capacity)

Queue<T> 

Fila,o primeiro que entra é o primeiro q sai.

Enqueue (adicionar), Dequeue (remover), peek

Queue<T>, Queue<T>(IEnumerable), Queue<T>()


Proprieadades: Count
métodos: 
Enqueue (T) - inclui no final da fila
Dequeue Retorna um item do inicio da fila e remove da fila.
Peek () - Retorna o item do inicio da fila sem removê-lo
Contains - verifica se um item existe na fila
clear() - Remove elementos da fila.

Coleções somente leitura

Permite que os dados sejam acessados mas não modificados.
System.Collections.ObjectModel.

ReadOnlyCollection<T> - criado a partir de uma coleção mutavel.
ReadOnlyDictionary<TKey, TValue> criado a partir de um dicionario mutavel.

contrutor  
public ReadOnlyCollection(ILIST<T>)

var planetas = new List<string>() {"Mercurio", "Venus", "Terra", "Marte"}
var listaPlanetas = new ReadOnlyCollection<string>(planetas)
ou
var notalista = planetas.AsReadOnly();

propriedades

Count - numero de elementos
Item - obtem o elemento especificado
Items - retorna um IList 

métodos (não tem os métodos add, remove ou clear)

Contains(T item)
CopyTo(T[] array, int arrayIndex)
GetEnumerator()
IndexOf(T item)

